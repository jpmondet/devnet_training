





Internet Engineering Task Force (IETF)                 M. Bjorklund, Ed.
Request for Comments: 7950                                Tail-f Systems
Category: Standards Track                                    August 2016
ISSN: 2070-1721


                  The YANG 1.1 Data Modeling Language

Abstract

   YANG is a data modeling language used to model configuration data,
   state data, Remote Procedure Calls, and notifications for network
   management protocols.  This document describes the syntax and
   semantics of version 1.1 of the YANG language.  YANG version 1.1 is a
   maintenance release of the YANG language, addressing ambiguities and
   defects in the original specification.  There are a small number of
   backward incompatibilities from YANG version 1.  This document also
   specifies the YANG mappings to the Network Configuration Protocol
   (NETCONF).

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in Section 2 of RFC 7841.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   http://www.rfc-editor.org/info/rfc7950.


















Bjorklund                    Standards Track                    [Page 1]

RFC 7950                        YANG 1.1                     August 2016


Copyright Notice

   Copyright (c) 2016 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

























Bjorklund                    Standards Track                    [Page 2]

RFC 7950                        YANG 1.1                     August 2016


Table of Contents

   1. Introduction ....................................................9
      1.1. Summary of Changes from RFC 6020 ..........................10
   2. Key Words ......................................................12
   3. Terminology ....................................................12
      3.1. A Note on Examples ........................................16
   4. YANG Overview ..................................................16
      4.1. Functional Overview .......................................16
      4.2. Language Overview .........................................18
           4.2.1. Modules and Submodules .............................18
           4.2.2. Data Modeling Basics ...............................19
           4.2.3. Configuration and State Data .......................23
           4.2.4. Built-In Types .....................................24
           4.2.5. Derived Types (typedef) ............................25
           4.2.6. Reusable Node Groups (grouping) ....................25
           4.2.7. Choices ............................................27
           4.2.8. Extending Data Models (augment) ....................28
           4.2.9. Operation Definitions ..............................29
           4.2.10. Notification Definitions ..........................31
   5. Language Concepts ..............................................32
      5.1. Modules and Submodules ....................................32
           5.1.1. Import and Include by Revision .....................33
           5.1.2. Module Hierarchies .................................34
      5.2. File Layout ...............................................36
      5.3. XML Namespaces ............................................36
           5.3.1. YANG XML Namespace .................................36
      5.4. Resolving Grouping, Type, and Identity Names ..............37
      5.5. Nested Typedefs and Groupings .............................37
      5.6. Conformance ...............................................38
           5.6.1. Basic Behavior .....................................38
           5.6.2. Optional Features ..................................38
           5.6.3. Deviations .........................................39
           5.6.4. Announcing Conformance Information in NETCONF ......40
           5.6.5. Implementing a Module ..............................40
      5.7. Datastore Modification ....................................44
   6. YANG Syntax ....................................................44
      6.1. Lexical Tokenization ......................................45
           6.1.1. Comments ...........................................45
           6.1.2. Tokens .............................................45
           6.1.3. Quoting ............................................45
      6.2. Identifiers ...............................................47
           6.2.1. Identifiers and Their Namespaces ...................47
      6.3. Statements ................................................48
           6.3.1. Language Extensions ................................48
      6.4. XPath Evaluations .........................................49
           6.4.1. XPath Context ......................................50
      6.5. Schema Node Identifier ....................................54



Bjorklund                    Standards Track                    [Page 3]

RFC 7950                        YANG 1.1                     August 2016


   7. YANG Statements ................................................55
      7.1. The "module" Statement ....................................55
           7.1.1. The module's Substatements .........................56
           7.1.2. The "yang-version" Statement .......................57
           7.1.3. The "namespace" Statement ..........................57
           7.1.4. The "prefix" Statement .............................57
           7.1.5. The "import" Statement .............................58
           7.1.6. The "include" Statement ............................59
           7.1.7. The "organization" Statement .......................60
           7.1.8. The "contact" Statement ............................60
           7.1.9. The "revision" Statement ...........................60
           7.1.10. Usage Example .....................................61
      7.2. The "submodule" Statement .................................62
           7.2.1. The submodule's Substatements ......................63
           7.2.2. The "belongs-to" Statement .........................63
           7.2.3. Usage Example ......................................64
      7.3. The "typedef" Statement ...................................65
           7.3.1. The typedef's Substatements ........................65
           7.3.2. The typedef's "type" Statement .....................65
           7.3.3. The "units" Statement ..............................65
           7.3.4. The typedef's "default" Statement ..................66
           7.3.5. Usage Example ......................................66
      7.4. The "type" Statement ......................................66
           7.4.1. The type's Substatements ...........................67
      7.5. The "container" Statement .................................67
           7.5.1. Containers with Presence ...........................67
           7.5.2. The container's Substatements ......................68
           7.5.3. The "must" Statement ...............................69
           7.5.4. The must's Substatements ...........................70
           7.5.5. The "presence" Statement ...........................71
           7.5.6. The container's Child Node Statements ..............71
           7.5.7. XML Encoding Rules .................................71
           7.5.8. NETCONF <edit-config> Operations ...................72
           7.5.9. Usage Example ......................................72
      7.6. The "leaf" Statement ......................................73
           7.6.1. The leaf's Default Value ...........................74
           7.6.2. The leaf's Substatements ...........................75
           7.6.3. The leaf's "type" Statement ........................75
           7.6.4. The leaf's "default" Statement .....................75
           7.6.5. The leaf's "mandatory" Statement ...................76
           7.6.6. XML Encoding Rules .................................76
           7.6.7. NETCONF <edit-config> Operations ...................76
           7.6.8. Usage Example ......................................77
      7.7. The "leaf-list" Statement .................................77
           7.7.1. Ordering ...........................................78
           7.7.2. The leaf-list's Default Values .....................79
           7.7.3. The leaf-list's Substatements ......................80
           7.7.4. The leaf-list's "default" Statement ................80



Bjorklund                    Standards Track                    [Page 4]

RFC 7950                        YANG 1.1                     August 2016


           7.7.5. The "min-elements" Statement .......................80
           7.7.6. The "max-elements" Statement .......................81
           7.7.7. The "ordered-by" Statement .........................81
           7.7.8. XML Encoding Rules .................................82
           7.7.9. NETCONF <edit-config> Operations ...................82
           7.7.10. Usage Example .....................................83
      7.8. The "list" Statement ......................................84
           7.8.1. The list's Substatements ...........................85
           7.8.2. The list's "key" Statement .........................85
           7.8.3. The list's "unique" Statement ......................86
           7.8.4. The list's Child Node Statements ...................87
           7.8.5. XML Encoding Rules .................................88
           7.8.6. NETCONF <edit-config> Operations ...................88
           7.8.7. Usage Example ......................................90
      7.9. The "choice" Statement ....................................93
           7.9.1. The choice's Substatements .........................94
           7.9.2. The choice's "case" Statement ......................94
           7.9.3. The choice's "default" Statement ...................96
           7.9.4. The choice's "mandatory" Statement .................98
           7.9.5. XML Encoding Rules .................................98
           7.9.6. Usage Example ......................................99
      7.10. The "anydata" Statement .................................100
           7.10.1. The anydata's Substatements ......................100
           7.10.2. XML Encoding Rules ...............................101
           7.10.3. NETCONF <edit-config> Operations .................101
           7.10.4. Usage Example ....................................101
      7.11. The "anyxml" Statement ..................................102
           7.11.1. The anyxml's Substatements .......................103
           7.11.2. XML Encoding Rules ...............................103
           7.11.3. NETCONF <edit-config> Operations .................103
           7.11.4. Usage Example ....................................104
      7.12. The "grouping" Statement ................................104
           7.12.1. The grouping's Substatements .....................105
           7.12.2. Usage Example ....................................105
      7.13. The "uses" Statement ....................................106
           7.13.1. The uses's Substatements .........................106
           7.13.2. The "refine" Statement ...........................106
           7.13.3. XML Encoding Rules ...............................107
           7.13.4. Usage Example ....................................107
      7.14. The "rpc" Statement .....................................108
           7.14.1. The rpc's Substatements ..........................109
           7.14.2. The "input" Statement ............................109
           7.14.3. The "output" Statement ...........................110
           7.14.4. NETCONF XML Encoding Rules .......................111
           7.14.5. Usage Example ....................................112






Bjorklund                    Standards Track                    [Page 5]

RFC 7950                        YANG 1.1                     August 2016


      7.15. The "action" Statement ..................................113
           7.15.1. The action's Substatements .......................114
           7.15.2. NETCONF XML Encoding Rules .......................114
           7.15.3. Usage Example ....................................115
      7.16. The "notification" Statement ............................116
           7.16.1. The notification's Substatements .................117
           7.16.2. NETCONF XML Encoding Rules .......................117
           7.16.3. Usage Example ....................................118
      7.17. The "augment" Statement .................................119
           7.17.1. The augment's Substatements ......................121
           7.17.2. XML Encoding Rules ...............................121
           7.17.3. Usage Example ....................................122
      7.18. The "identity" Statement ................................124
           7.18.1. The identity's Substatements .....................124
           7.18.2. The "base" Statement .............................124
           7.18.3. Usage Example ....................................125
      7.19. The "extension" Statement ...............................126
           7.19.1. The extension's Substatements ....................126
           7.19.2. The "argument" Statement .........................127
           7.19.3. Usage Example ....................................127
      7.20. Conformance-Related Statements ..........................128
           7.20.1. The "feature" Statement ..........................128
           7.20.2. The "if-feature" Statement .......................130
           7.20.3. The "deviation" Statement ........................131
      7.21. Common Statements .......................................134
           7.21.1. The "config" Statement ...........................134
           7.21.2. The "status" Statement ...........................135
           7.21.3. The "description" Statement ......................136
           7.21.4. The "reference" Statement ........................136
           7.21.5. The "when" Statement .............................136
   8. Constraints ...................................................138
      8.1. Constraints on Data ......................................138
      8.2. Configuration Data Modifications .........................139
      8.3. NETCONF Constraint Enforcement Model .....................139
           8.3.1. Payload Parsing ...................................139
           8.3.2. NETCONF <edit-config> Processing ..................140
           8.3.3. Validation ........................................141
   9. Built-In Types ................................................141
      9.1. Canonical Representation .................................141
      9.2. The Integer Built-In Types ...............................142
           9.2.1. Lexical Representation ............................142
           9.2.2. Canonical Form ....................................143
           9.2.3. Restrictions ......................................143
           9.2.4. The "range" Statement .............................143
           9.2.5. Usage Example .....................................144






Bjorklund                    Standards Track                    [Page 6]

RFC 7950                        YANG 1.1                     August 2016


      9.3. The decimal64 Built-In Type ..............................144
           9.3.1. Lexical Representation ............................145
           9.3.2. Canonical Form ....................................145
           9.3.3. Restrictions ......................................145
           9.3.4. The "fraction-digits" Statement ...................145
           9.3.5. Usage Example .....................................146
      9.4. The string Built-In Type .................................146
           9.4.1. Lexical Representation ............................146
           9.4.2. Canonical Form ....................................147
           9.4.3. Restrictions ......................................147
           9.4.4. The "length" Statement ............................147
           9.4.5. The "pattern" Statement ...........................148
           9.4.6. The "modifier" Statement ..........................148
           9.4.7. Usage Example .....................................149
      9.5. The boolean Built-In Type ................................150
           9.5.1. Lexical Representation ............................150
           9.5.2. Canonical Form ....................................150
           9.5.3. Restrictions ......................................150
      9.6. The enumeration Built-In Type ............................150
           9.6.1. Lexical Representation ............................150
           9.6.2. Canonical Form ....................................151
           9.6.3. Restrictions ......................................151
           9.6.4. The "enum" Statement ..............................151
           9.6.5. Usage Example .....................................152
      9.7. The bits Built-In Type ...................................154
           9.7.1. Restrictions ......................................154
           9.7.2. Lexical Representation ............................154
           9.7.3. Canonical Form ....................................154
           9.7.4. The "bit" Statement ...............................155
           9.7.5. Usage Example .....................................156
      9.8. The binary Built-In Type .................................157
           9.8.1. Restrictions ......................................157
           9.8.2. Lexical Representation ............................157
           9.8.3. Canonical Form ....................................157
      9.9. The leafref Built-In Type ................................157
           9.9.1. Restrictions ......................................158
           9.9.2. The "path" Statement ..............................158
           9.9.3. The "require-instance" Statement ..................159
           9.9.4. Lexical Representation ............................159
           9.9.5. Canonical Form ....................................159
           9.9.6. Usage Example .....................................159
      9.10. The identityref Built-In Type ...........................163
           9.10.1. Restrictions .....................................163
           9.10.2. The identityref's "base" Statement ...............163
           9.10.3. Lexical Representation ...........................163
           9.10.4. Canonical Form ...................................164
           9.10.5. Usage Example ....................................164




Bjorklund                    Standards Track                    [Page 7]

RFC 7950                        YANG 1.1                     August 2016


      9.11. The empty Built-In Type .................................165
           9.11.1. Restrictions .....................................165
           9.11.2. Lexical Representation ...........................165
           9.11.3. Canonical Form ...................................165
           9.11.4. Usage Example ....................................166
      9.12. The union Built-In Type .................................166
           9.12.1. Restrictions .....................................166
           9.12.2. Lexical Representation ...........................166
           9.12.3. Canonical Form ...................................167
           9.12.4. Usage Example ....................................167
      9.13. The instance-identifier Built-In Type ...................168
           9.13.1. Restrictions .....................................168
           9.13.2. Lexical Representation ...........................169
           9.13.3. Canonical Form ...................................169
           9.13.4. Usage Example ....................................169
   10. XPath Functions ..............................................170
      10.1. Function for Node Sets ..................................170
           10.1.1. current() ........................................170
      10.2. Function for Strings ....................................170
           10.2.1. re-match() .......................................170
      10.3. Function for the YANG Types "leafref" and
            "instance-identifier" ...................................171
           10.3.1. deref() ..........................................171
      10.4. Functions for the YANG Type "identityref" ...............172
           10.4.1. derived-from() ...................................172
           10.4.2. derived-from-or-self() ...........................174
      10.5. Function for the YANG Type "enumeration" ................174
           10.5.1. enum-value() .....................................174
      10.6. Function for the YANG Type "bits" .......................175
           10.6.1. bit-is-set() .....................................175
   11. Updating a Module ............................................176
   12. Coexistence with YANG Version 1 ..............................179
   13. YIN ..........................................................179
      13.1. Formal YIN Definition ...................................180
           13.1.1. Usage Example ....................................182
   14. YANG ABNF Grammar ............................................184
   15. NETCONF Error Responses for YANG-Related Errors ..............211
      15.1. Error Message for Data That Violates a "unique"
            Statement ...............................................211
      15.2. Error Message for Data That Violates a
            "max-elements" Statement ................................211
      15.3. Error Message for Data That Violates a
            "min-elements" Statement ................................211
      15.4. Error Message for Data That Violates a "must"
            Statement ...............................................212
      15.5. Error Message for Data That Violates a
            "require-instance" Statement ............................212




Bjorklund                    Standards Track                    [Page 8]

RFC 7950                        YANG 1.1                     August 2016


      15.6. Error Message for Data That Violates a Mandatory
            "choice" Statement ......................................212
      15.7. Error Message for the "insert" Operation ................212
   16. IANA Considerations ..........................................213
   17. Security Considerations ......................................213
   18. References ...................................................214
      18.1. Normative References ....................................214
      18.2. Informative References ..................................215
   Acknowledgements .................................................217
   Contributors .....................................................217
   Author's Address .................................................217

1.  Introduction

   YANG is a data modeling language originally designed to model
   configuration and state data manipulated by the Network Configuration
   Protocol (NETCONF), NETCONF Remote Procedure Calls, and NETCONF
   notifications [RFC6241].  Since the publication of YANG version 1
   [RFC6020], YANG has been used or proposed to be used for other
   protocols (e.g., RESTCONF [RESTCONF] and the Constrained Application
   Protocol (CoAP) Management Interface (CoMI) [CoMI]).  Further,
   encodings other than XML have been proposed (e.g., JSON [RFC7951]).

   This document describes the syntax and semantics of version 1.1 of
   the YANG language.  It also describes how a data model defined in a
   YANG module is encoded in the Extensible Markup Language (XML) [XML]
   and how NETCONF operations are used to manipulate the data.  Other
   protocols and encodings are possible but are out of scope for this
   specification.

   In terms of developing YANG data models, [YANG-Guidelines] provides
   some guidelines and recommendations.

   Note that this document does not obsolete RFC 6020 [RFC6020].

















Bjorklund                    Standards Track                    [Page 9]

RFC 7950                        YANG 1.1                     August 2016


1.1.  Summary of Changes from RFC 6020

   This document defines version 1.1 of the YANG language.  YANG
   version 1.1 is a maintenance release of the YANG language, addressing
   ambiguities and defects in the original specification [RFC6020].

   The following changes are not backward compatible with YANG
   version 1:

   o  Changed the rules for the interpretation of escaped characters in
      double-quoted strings.  This is a backward-incompatible change
      from YANG version 1.  When updating a YANG version 1 module to 1.1
      and the module uses a character sequence that is now illegal, the
      string must be changed to match the new rules.  See Section 6.1.3
      for details.

   o  An unquoted string cannot contain any single or double quote
      characters.  This is a backward-incompatible change from YANG
      version 1.  When updating a YANG version 1 module to 1.1 and the
      module uses such quote characters, the string must be changed to
      match the new rules.  See Section 6.1.3 for details.

   o  Made "when" and "if-feature" illegal on list keys.  This is a
      backward-incompatible change from YANG version 1.  When updating a
      YANG version 1 module to 1.1 and the module uses these constructs,
      they must be removed to match the new rules.

   o  Defined the legal characters in YANG modules.  When updating a
      YANG version 1 module to 1.1, any characters that are now illegal
      must be removed.  See Section 6 for details.

   o  Made noncharacters illegal in the built-in type "string".  This
      change affects the runtime behavior of YANG-based protocols.

   The following additional changes have been done to YANG:

   o  Changed the YANG version from "1" to "1.1".

   o  Made the "yang-version" statement mandatory in YANG version "1.1".

   o  Extended the "if-feature" syntax to be a boolean expression over
      feature names.

   o  Allow "if-feature" in "bit", "enum", and "identity".

   o  Allow "if-feature" in "refine".





Bjorklund                    Standards Track                   [Page 10]

RFC 7950                        YANG 1.1                     August 2016


   o  Allow "choice" as a shorthand "case" statement (see
      Section 7.9.2).

   o  Added a new substatement "modifier" to the "pattern" statement
      (see Section 9.4.6).

   o  Allow "must" in "input", "output", and "notification".

   o  Allow "require-instance" in leafref.

   o  Allow "description" and "reference" in "import" and "include".

   o  Allow imports of multiple revisions of a module.

   o  Allow "augment" to add conditionally mandatory nodes (see
      Section 7.17).

   o  Added a set of new XML Path Language (XPath) functions in
      Section 10.

   o  Clarified the XPath context's tree in Section 6.4.1.

   o  Defined the string value of an identityref in XPath expressions
      (see Section 9.10).

   o  Clarified what unprefixed names mean in leafrefs in typedefs (see
      Sections 6.4.1 and 9.9.2).

   o  Allow identities to be derived from multiple base identities (see
      Sections 7.18 and 9.10).

   o  Allow enumerations and bits to be subtyped (see Sections 9.6
      and 9.7).

   o  Allow leaf-lists to have default values (see Section 7.7.2).

   o  Allow non-unique values in non-configuration leaf-lists (see
      Section 7.7).

   o  Use syntax for case-sensitive strings (as per [RFC7405]) in the
      grammar.

   o  Changed the module advertisement mechanism (see Section 5.6.4).

   o  Changed the scoping rules for definitions in submodules.  A
      submodule can now reference all definitions in all submodules that
      belong to the same module, without using the "include" statement.




Bjorklund                    Standards Track                   [Page 11]

RFC 7950                        YANG 1.1                     August 2016


   o  Added a new statement "action", which is used to define operations
      tied to data nodes.

   o  Allow notifications to be tied to data nodes.

   o  Added a new data definition statement "anydata" (see
      Section 7.10), which is RECOMMENDED to be used instead of "anyxml"
      when the data can be modeled in YANG.

   o  Allow types "empty" and "leafref" in unions.

   o  Allow type "empty" in a key.

   o  Removed the restriction that identifiers could not start with the
      characters "xml".

   The following changes have been done to the NETCONF mapping:

   o  A server advertises support for YANG 1.1 modules by using
      ietf-yang-library [RFC7895] instead of listing them as
      capabilities in the <hello> message.

2.  Key Words

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119].

3.  Terminology

   The following terms are used within this document:

   o  action: An operation defined for a node in the data tree.

   o  anydata: A data node that can contain an unknown set of nodes that
      can be modeled by YANG, except anyxml.

   o  anyxml: A data node that can contain an unknown chunk of XML data.

   o  augment: Adds new schema nodes to a previously defined schema
      node.

   o  base type: The type from which a derived type was derived, which
      may be either a built-in type or another derived type.

   o  built-in type: A YANG data type defined in the YANG language, such
      as uint32 or string.



Bjorklund                    Standards Track                   [Page 12]

RFC 7950                        YANG 1.1                     August 2016


   o  choice: A schema node where only one of a number of identified
      alternatives is valid.

   o  client: An entity that can access YANG-defined data on a server,
      over some network management protocol.

   o  conformance: A measure of how accurately a server follows a data
      model.

   o  container: An interior data node that exists in at most one
      instance in the data tree.  A container has no value, but rather a
      set of child nodes.

   o  data definition statement: A statement that defines new data
      nodes.  One of "container", "leaf", "leaf-list", "list", "choice",
      "case", "augment", "uses", "anydata", and "anyxml".

   o  data model: A data model describes how data is represented and
      accessed.

   o  data node: A node in the schema tree that can be instantiated in a
      data tree.  One of container, leaf, leaf-list, list, anydata, and
      anyxml.

   o  data tree: An instantiated tree of any data modeled with YANG,
      e.g., configuration data, state data, combined configuration and
      state data, RPC or action input, RPC or action output, or
      notification.

   o  derived type: A type that is derived from a built-in type (such as
      uint32) or another derived type.

   o  extension: An extension attaches non-YANG semantics to statements.
      The "extension" statement defines new statements to express these
      semantics.

   o  feature: A mechanism for marking a portion of the model as
      optional.  Definitions can be tagged with a feature name and are
      only valid on servers that support that feature.

   o  grouping: A reusable set of schema nodes, which may be used
      locally in the module and by other modules that import from it.
      The "grouping" statement is not a data definition statement and,
      as such, does not define any nodes in the schema tree.

   o  identifier: A string used to identify different kinds of YANG
      items by name.




Bjorklund                    Standards Track                   [Page 13]

RFC 7950                        YANG 1.1                     August 2016


   o  identity: A globally unique, abstract, and untyped name.

   o  instance identifier: A mechanism for identifying a particular node
      in a data tree.

   o  interior node: Nodes within a hierarchy that are not leaf nodes.

   o  leaf: A data node that exists in at most one instance in the data
      tree.  A leaf has a value but no child nodes.

   o  leaf-list: Like the leaf node but defines a set of uniquely
      identifiable nodes rather than a single node.  Each node has a
      value but no child nodes.

   o  list: An interior data node that may exist in multiple instances
      in the data tree.  A list has no value, but rather a set of child
      nodes.

   o  mandatory node: A mandatory node is one of:

      *  A leaf, choice, anydata, or anyxml node with a "mandatory"
         statement with the value "true".

      *  A list or leaf-list node with a "min-elements" statement with a
         value greater than zero.

      *  A container node without a "presence" statement and that has at
         least one mandatory node as a child.

   o  module: A YANG module defines hierarchies of schema nodes.  With
      its definitions and the definitions it imports or includes from
      elsewhere, a module is self-contained and "compilable".

   o  non-presence container: A container that has no meaning of its
      own, existing only to contain child nodes.

   o  presence container: A container where the presence of the
      container itself carries some meaning.

   o  RPC: A Remote Procedure Call.

   o  RPC operation: A specific Remote Procedure Call.

   o  schema node: A node in the schema tree.  One of action, container,
      leaf, leaf-list, list, choice, case, rpc, input, output,
      notification, anydata, and anyxml.





Bjorklund                    Standards Track                   [Page 14]

RFC 7950                        YANG 1.1                     August 2016


   o  schema node identifier: A mechanism for identifying a particular
      node in the schema tree.

   o  schema tree: The definition hierarchy specified within a module.

   o  server: An entity that provides access to YANG-defined data to a
      client, over some network management protocol.

   o  server deviation: A failure of the server to implement a module
      faithfully.

   o  submodule: A partial module definition that contributes derived
      types, groupings, data nodes, RPCs, actions, and notifications to
      a module.  A YANG module can be constructed from a number of
      submodules.

   o  top-level data node: A data node where there is no other data node
      between it and a "module" or "submodule" statement.

   o  uses: The "uses" statement is used to instantiate the set of
      schema nodes defined in a "grouping" statement.  The instantiated
      nodes may be refined and augmented to tailor them to any specific
      needs.

   o  value space: For a data type; the set of values permitted by the
      data type.  For a leaf or leaf-list instance; the value space of
      its data type.

   The following terms are defined in [RFC6241]:

   o  configuration data

   o  configuration datastore

   o  datastore

   o  state data

   When modeled with YANG, a datastore is realized as an instantiated
   data tree.

   When modeled with YANG, a configuration datastore is realized as an
   instantiated data tree with configuration data.








Bjorklund                    Standards Track                   [Page 15]

RFC 7950                        YANG 1.1                     August 2016


3.1.  A Note on Examples

   Throughout this document, there are many examples of YANG statements.
   These examples are supposed to illustrate certain features and are
   not supposed to be complete, valid YANG modules.

4.  YANG Overview

   This non-normative section is intended to give a high-level overview
   of YANG to first-time readers.

4.1.  Functional Overview

   YANG is a language originally designed to model data for the NETCONF
   protocol.  A YANG module defines hierarchies of data that can be used
   for NETCONF-based operations, including configuration, state data,
   RPCs, and notifications.  This allows a complete description of all
   data sent between a NETCONF client and server.  Although out of scope
   for this specification, YANG can also be used with protocols other
   than NETCONF.

   YANG models the hierarchical organization of data as a tree in which
   each node has a name, and either a value or a set of child nodes.
   YANG provides clear and concise descriptions of the nodes, as well as
   the interaction between those nodes.

   YANG structures data models into modules and submodules.  A module
   can import definitions from other external modules and can include
   definitions from submodules.  The hierarchy can be augmented,
   allowing one module to add data nodes to the hierarchy defined in
   another module.  This augmentation can be conditional, with new nodes
   appearing only if certain conditions are met.

   YANG data models can describe constraints to be enforced on the data,
   restricting the presence or value of nodes based on the presence or
   value of other nodes in the hierarchy.  These constraints are
   enforceable by either the client or the server.

   YANG defines a set of built-in types and has a type mechanism through
   which additional types may be defined.  Derived types can restrict
   their base type's set of valid values using mechanisms like range or
   pattern restrictions that can be enforced by clients or servers.
   They can also define usage conventions for use of the derived type,
   such as a string-based type that contains a hostname.







Bjorklund                    Standards Track                   [Page 16]

RFC 7950                        YANG 1.1                     August 2016


   YANG permits the definition of reusable groupings of nodes.  The
   usage of these groupings can refine or augment the nodes, allowing it
   to tailor the nodes to its particular needs.  Derived types and
   groupings can be defined in one module and used in either the same
   module or another module that imports it.

   YANG data hierarchy constructs include defining lists where list
   entries are identified by keys that distinguish them from each other.
   Such lists may be defined as either sorted by user or automatically
   sorted by the system.  For user-sorted lists, operations are defined
   for manipulating the order of the list entries.

   YANG modules can be translated into an equivalent XML syntax called
   YANG Independent Notation (YIN) (Section 13), allowing applications
   using XML parsers and Extensible Stylesheet Language Transformations
   (XSLT) scripts to operate on the models.  The conversion from YANG to
   YIN is semantically lossless, so content in YIN can be round-tripped
   back into YANG.

   YANG is an extensible language, allowing extensions to be defined by
   standards bodies, vendors, and individuals.  The statement syntax
   allows these extensions to coexist with standard YANG statements in a
   natural way, while extensions in a YANG module stand out sufficiently
   for the reader to notice them.

   YANG resists the tendency to solve all possible problems, limiting
   the problem space to allow expression of data models for network
   management protocols such as NETCONF, not arbitrary XML documents or
   arbitrary data models.

   To the extent possible, YANG maintains compatibility with the Simple
   Network Management Protocol's (SNMP's) SMIv2 (Structure of Management
   Information version 2 [RFC2578] [RFC2579]).  SMIv2-based MIB modules
   can be automatically translated into YANG modules for read-only
   access [RFC6643].  However, YANG is not concerned with reverse
   translation from YANG to SMIv2.















Bjorklund                    Standards Track                   [Page 17]

RFC 7950                        YANG 1.1                     August 2016


4.2.  Language Overview

   This section introduces some important constructs used in YANG that
   will aid in the understanding of the language specifics in later
   sections.

4.2.1.  Modules and Submodules

   YANG data models are defined in modules.  A module contains a
   collection of related definitions.

   A module contains three types of statements: module header
   statements, "revision" statements, and definition statements.  The
   module header statements describe the module and give information
   about the module itself, the "revision" statements give information
   about the history of the module, and the definition statements are
   the body of the module where the data model is defined.

   A server may implement a number of modules, allowing multiple views
   of the same data or multiple views of disjoint subsections of the
   server's data.  Alternatively, the server may implement only one
   module that defines all available data.

   A module may have portions of its definitions separated into
   submodules, based on the needs of the module designer.  The external
   view remains that of a single module, regardless of the presence or
   size of its submodules.

   The "import" statement allows a module or submodule to reference
   definitions defined in other modules.

   The "include" statement is used in a module to identify each
   submodule that belongs to it.


















Bjorklund                    Standards Track                   [Page 18]

RFC 7950                        YANG 1.1                     August 2016


4.2.2.  Data Modeling Basics

   YANG defines four main types of data nodes for data modeling.  In
   each of the following subsections, the examples show the YANG syntax
   as well as a corresponding XML encoding.  The syntax of YANG
   statements is defined in Section 6.3.

4.2.2.1.  Leaf Nodes

   A leaf instance contains simple data like an integer or a string.  It
   has exactly one value of a particular type and no child nodes.

   YANG Example:

     leaf host-name {
       type string;
       description
         "Hostname for this system.";
     }

   XML Encoding Example:

     <host-name>my.example.com</host-name>

   The "leaf" statement is covered in Section 7.6.

4.2.2.2.  Leaf-List Nodes

   A leaf-list defines a sequence of values of a particular type.

   YANG Example:

     leaf-list domain-search {
       type string;
       description
         "List of domain names to search.";
     }

   XML Encoding Example:

     <domain-search>high.example.com</domain-search>
     <domain-search>low.example.com</domain-search>
     <domain-search>everywhere.example.com</domain-search>

   The "leaf-list" statement is covered in Section 7.7.






Bjorklund                    Standards Track                   [Page 19]

RFC 7950                        YANG 1.1                     August 2016


4.2.2.3.  Container Nodes

   A container is used to group related nodes in a subtree.  A container
   has only child nodes and no value.  A container may contain any
   number of child nodes of any type (leafs, lists, containers,
   leaf-lists, actions, and notifications).

   YANG Example:

     container system {
       container login {
         leaf message {
           type string;
           description
             "Message given at start of login session.";
         }
       }
     }

   XML Encoding Example:

     <system>
       <login>
         <message>Good morning</message>
       </login>
     </system>

   The "container" statement is covered in Section 7.5.























Bjorklund                    Standards Track                   [Page 20]

RFC 7950                        YANG 1.1                     August 2016


4.2.2.4.  List Nodes

   A list defines a sequence of list entries.  Each entry is like a
   container and is uniquely identified by the values of its key leafs
   if it has any key leafs defined.  A list can define multiple key
   leafs and may contain any number of child nodes of any type
   (including leafs, lists, containers, etc.).

   YANG Example:

     list user {
       key "name";
       leaf name {
         type string;
       }
       leaf full-name {
         type string;
       }
       leaf class {
         type string;
       }
     }

   XML Encoding Example:

     <user>
       <name>glocks</name>
       <full-name>Goldie Locks</full-name>
       <class>intruder</class>
     </user>
     <user>
       <name>snowey</name>
       <full-name>Snow White</full-name>
       <class>free-loader</class>
     </user>
     <user>
       <name>rzell</name>
       <full-name>Rapun Zell</full-name>
       <class>tower</class>
     </user>

   The "list" statement is covered in Section 7.8.









Bjorklund                    Standards Track                   [Page 21]

RFC 7950                        YANG 1.1                     August 2016


4.2.2.5.  Example Module

   These statements are combined to define the module:

     // Contents of "example-system.yang"
     module example-system {
       yang-version 1.1;
       namespace "urn:example:system";
       prefix "sys";

       organization "Example Inc.";
       contact "joe@example.com";
       description
         "The module for entities implementing the Example system.";

       revision 2007-06-09 {
         description "Initial revision.";
       }

       container system {
         leaf host-name {
           type string;
           description
             "Hostname for this system.";
         }

         leaf-list domain-search {
           type string;
           description
             "List of domain names to search.";
         }

         container login {
           leaf message {
             type string;
             description
               "Message given at start of login session.";
           }













Bjorklund                    Standards Track                   [Page 22]

RFC 7950                        YANG 1.1                     August 2016


           list user {
             key "name";
             leaf name {
               type string;
             }
             leaf full-name {
               type string;
             }
             leaf class {
               type string;
             }
           }
         }
       }
     }

4.2.3.  Configuration and State Data

   YANG can model state data, as well as configuration data, based on
   the "config" statement.  When a node is tagged with "config false",
   its subhierarchy is flagged as state data.  If it is tagged with
   "config true", its subhierarchy is flagged as configuration data.
   Parent containers, lists, and key leafs are reported also, giving the
   context for the state data.

   In this example, two leafs are defined for each interface, a
   configured speed and an observed speed.

     list interface {
       key "name";
       config true;

       leaf name {
         type string;
       }
       leaf speed {
         type enumeration {
           enum 10m;
           enum 100m;
           enum auto;
         }
       }
       leaf observed-speed {
         type uint32;
         config false;
       }
     }




Bjorklund                    Standards Track                   [Page 23]

RFC 7950                        YANG 1.1                     August 2016


   The "config" statement is covered in Section 7.21.1.

4.2.4.  Built-In Types

   YANG has a set of built-in types, similar to those of many
   programming languages, but with some differences due to special
   requirements of network management.  The following table summarizes
   the built-in types discussed in Section 9:

       +---------------------+-------------------------------------+
       | Name                | Description                         |
       +---------------------+-------------------------------------+
       | binary              | Any binary data                     |
       | bits                | A set of bits or flags              |
       | boolean             | "true" or "false"                   |
       | decimal64           | 64-bit signed decimal number        |
       | empty               | A leaf that does not have any value |
       | enumeration         | One of an enumerated set of strings |
       | identityref         | A reference to an abstract identity |
       | instance-identifier | A reference to a data tree node     |
       | int8                | 8-bit signed integer                |
       | int16               | 16-bit signed integer               |
       | int32               | 32-bit signed integer               |
       | int64               | 64-bit signed integer               |
       | leafref             | A reference to a leaf instance      |
       | string              | A character string                  |
       | uint8               | 8-bit unsigned integer              |
       | uint16              | 16-bit unsigned integer             |
       | uint32              | 32-bit unsigned integer             |
       | uint64              | 64-bit unsigned integer             |
       | union               | Choice of member types              |
       +---------------------+-------------------------------------+

   The "type" statement is covered in Section 7.4.

















Bjorklund                    Standards Track                   [Page 24]

RFC 7950                        YANG 1.1                     August 2016


4.2.5.  Derived Types (typedef)

   YANG can define derived types from base types using the "typedef"
   statement.  A base type can be either a built-in type or a derived
   type, allowing a hierarchy of derived types.

   A derived type can be used as the argument for the "type" statement.

   YANG Example:

     typedef percent {
       type uint8 {
         range "0 .. 100";
       }
     }

     leaf completed {
       type percent;
     }

   XML Encoding Example:

     <completed>20</completed>

   The "typedef" statement is covered in Section 7.3.

4.2.6.  Reusable Node Groups (grouping)

   Groups of nodes can be assembled into reusable collections using the
   "grouping" statement.  A grouping defines a set of nodes that are
   instantiated with the "uses" statement.

   YANG Example:

     grouping target {
       leaf address {
         type inet:ip-address;
         description "Target IP address.";
       }
       leaf port {
         type inet:port-number;
          description "Target port number.";
       }
     }







Bjorklund                    Standards Track                   [Page 25]

RFC 7950                        YANG 1.1                     August 2016


     container peer {
       container destination {
         uses target;
       }
     }

   XML Encoding Example:

     <peer>
       <destination>
         <address>2001:db8::2</address>
         <port>830</port>
       </destination>
     </peer>

   The grouping can be refined as it is used, allowing certain
   statements to be overridden.  In this example, the description is
   refined:

     container connection {
       container source {
         uses target {
           refine "address" {
             description "Source IP address.";
           }
           refine "port" {
             description "Source port number.";
           }
         }
       }
       container destination {
         uses target {
           refine "address" {
             description "Destination IP address.";
           }
           refine "port" {
             description "Destination port number.";
           }
         }
       }
     }

   The "grouping" statement is covered in Section 7.12.








Bjorklund                    Standards Track                   [Page 26]

RFC 7950                        YANG 1.1                     August 2016


4.2.7.  Choices

   YANG allows the data model to segregate incompatible nodes into
   distinct choices using the "choice" and "case" statements.  The
   "choice" statement contains a set of "case" statements that define
   sets of schema nodes that cannot appear together.  Each "case" may
   contain multiple nodes, but each node may appear in only one "case"
   under a "choice".

   The choice and case nodes appear only in the schema tree and not in
   the data tree.  The additional levels of hierarchy are not needed
   beyond the conceptual schema.  The presence of a case is indicated by
   the presence of one or more of the nodes within it.

   Since only one of the choice's cases can be valid at any time, when a
   node from one case is created in the data tree, all nodes from all
   other cases are implicitly deleted.  The server handles the
   enforcement of the constraint, preventing incompatibilities from
   existing in the configuration.

   YANG Example:

     container food {
       choice snack {
         case sports-arena {
           leaf pretzel {
             type empty;
           }
           leaf beer {
             type empty;
           }
         }
         case late-night {
           leaf chocolate {
             type enumeration {
               enum dark;
               enum milk;
               enum first-available;
             }
           }
         }
       }
     }








Bjorklund                    Standards Track                   [Page 27]

RFC 7950                        YANG 1.1                     August 2016


   XML Encoding Example:

     <food>
       <pretzel/>
       <beer/>
     </food>

   The "choice" statement is covered in Section 7.9.

4.2.8.  Extending Data Models (augment)

   YANG allows a module to insert additional nodes into data models,
   including both the current module (and its submodules) and an
   external module.  This is useful, for example, for vendors to add
   vendor-specific parameters to standard data models in an
   interoperable way.

   The "augment" statement defines the location in the data model
   hierarchy where new nodes are inserted, and the "when" statement
   defines the conditions when the new nodes are valid.

   When a server implements a module containing an "augment" statement,
   that implies that the server's implementation of the augmented module
   contains the additional nodes.

   YANG Example:

     augment /system/login/user {
       when "class != 'wheel'";
       leaf uid {
         type uint16 {
           range "1000 .. 30000";
         }
       }
     }

   This example defines a "uid" node that is valid only when the user's
   "class" is not "wheel".













Bjorklund                    Standards Track                   [Page 28]

RFC 7950                        YANG 1.1                     August 2016


   If a module augments another module, the XML elements that are added
   to the encoding are in the namespace of the augmenting module.  For
   example, if the above augmentation were in a module with prefix
   "other", the XML would look like:

   XML Encoding Example:

     <user>
       <name>alicew</name>
       <full-name>Alice N. Wonderland</full-name>
       <class>drop-out</class>
       <other:uid>1024</other:uid>
     </user>

   The "augment" statement is covered in Section 7.17.

4.2.9.  Operation Definitions

   YANG allows the definition of operations.  The operations' names,
   input parameters, and output parameters are modeled using YANG data
   definition statements.  Operations on the top level in a module are
   defined with the "rpc" statement.  Operations can also be tied to a
   container or list data node.  Such operations are defined with the
   "action" statement.

   YANG Example for an operation at the top level:

     rpc activate-software-image {
       input {
         leaf image-name {
           type string;
         }
       }
       output {
         leaf status {
           type string;
         }
       }
     }












Bjorklund                    Standards Track                   [Page 29]

RFC 7950                        YANG 1.1                     August 2016


   NETCONF XML Example:

     <rpc message-id="101"
          xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
       <activate-software-image xmlns="http://example.com/system">
         <image-name>example-fw-2.3</image-name>
       </activate-software-image>
     </rpc>

     <rpc-reply message-id="101"
                xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
       <status xmlns="http://example.com/system">
         The image example-fw-2.3 is being installed.
       </status>
     </rpc-reply>

   YANG Example for an operation tied to a list data node:

     list interface {
       key "name";

       leaf name {
         type string;
       }

       action ping {
         input {
           leaf destination {
             type inet:ip-address;
           }
         }
         output {
           leaf packet-loss {
             type uint8;
           }
         }
       }
     }













Bjorklund                    Standards Track                   [Page 30]

RFC 7950                        YANG 1.1                     August 2016


   NETCONF XML Example:

     <rpc message-id="102"
          xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
       <action xmlns="urn:ietf:params:xml:ns:yang:1">
         <interface xmlns="http://example.com/system">
           <name>eth1</name>
           <ping>
             <destination>192.0.2.1</destination>
           </ping>
         </interface>
       </action>
     </rpc>

     <rpc-reply message-id="102"
                xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
                xmlns:sys="http://example.com/system">
       <sys:packet-loss>60</sys:packet-loss>
     </rpc-reply>

   The "rpc" statement is covered in Section 7.14, and the "action"
   statement is covered in Section 7.15.

4.2.10.  Notification Definitions

   YANG allows the definition of notifications.  YANG data definition
   statements are used to model the content of the notification.

   YANG Example:

     notification link-failure {
       description
         "A link failure has been detected.";
       leaf if-name {
         type leafref {
           path "/interface/name";
         }
       }
       leaf if-admin-status {
         type admin-status;
       }
       leaf if-oper-status {
         type oper-status;
       }
     }






Bjorklund                    Standards Track                   [Page 31]

RFC 7950                        YANG 1.1                     August 2016


   NETCONF XML Example:

     <notification
         xmlns="urn:ietf:params:netconf:capability:notification:1.0">
       <eventTime>2007-09-01T10:00:00Z</eventTime>
       <link-failure xmlns="urn:example:system">
         <if-name>so-1/2/3.0</if-name>
         <if-admin-status>up</if-admin-status>
         <if-oper-status>down</if-oper-status>
       </link-failure>
     </notification>

   The "notification" statement is covered in Section 7.16.

5.  Language Concepts

5.1.  Modules and Submodules

   The module is the base unit of definition in YANG.  A module defines
   a single data model.  A module can also augment an existing data
   model with additional nodes.

   Submodules are partial modules that contribute definitions to a
   module.  A module may include any number of submodules, but each
   submodule may belong to only one module.

   Developers of YANG modules and submodules are RECOMMENDED to choose
   names for their modules that will have a low probability of colliding
   with standard or other enterprise modules, e.g., by using the
   enterprise or organization name as a prefix for the module name.
   Within a server, all module names MUST be unique.

   A module uses the "include" statement to list all its submodules.  A
   module, or submodule belonging to that module, can reference
   definitions in the module and all submodules included by the module.

   A module or submodule uses the "import" statement to reference
   external modules.  Statements in the module or submodule can
   reference definitions in the external module using the prefix
   specified in the "import" statement.

   For backward compatibility with YANG version 1, a submodule MAY use
   the "include" statement to reference other submodules within its
   module, but this is not necessary in YANG version 1.1.  A submodule
   can reference any definition in the module it belongs to and in all
   submodules included by the module.  A submodule MUST NOT include
   different revisions of other submodules than the revisions that its
   module includes.



Bjorklund                    Standards Track                   [Page 32]

RFC 7950                        YANG 1.1                     August 2016


   A module or submodule MUST NOT include submodules from other modules,
   and a submodule MUST NOT import its own module.

   The "import" and "include" statements are used to make definitions
   available from other modules:

   o  For a module or submodule to reference definitions in an external
      module, the external module MUST be imported.

   o  A module MUST include all its submodules.

   o  A module, or submodule belonging to that module, MAY reference
      definitions in the module and all submodules included by the
      module.

   There MUST NOT be any circular chains of imports.  For example, if
   module "a" imports module "b", "b" cannot import "a".

   When a definition in an external module is referenced, a locally
   defined prefix MUST be used, followed by a colon (":") and then the
   external identifier.  References to definitions in the local module
   MAY use the prefix notation.  Since built-in data types do not belong
   to any module and have no prefix, references to built-in data types
   (e.g., int32) cannot use the prefix notation.  The syntax for a
   reference to a definition is formally defined by the rule
   "identifier-ref" in Section 14.

5.1.1.  Import and Include by Revision

   Published modules evolve independently over time.  In order to allow
   for this evolution, modules can be imported using specific revisions.
   Initially, a module imports the revisions of other modules that are
   current when the module is written.  As future revisions of the
   imported modules are published, the importing module is unaffected
   and its contents are unchanged.  When the author of the module is
   prepared to move to the most recently published revision of an
   imported module, the module is republished with an updated "import"
   statement.  By republishing with the new revision, the authors
   explicitly indicate their acceptance of any changes in the imported
   module.

   For submodules, the issue is related but simpler.  A module or
   submodule that includes submodules may specify the revision of the
   included submodules.  If a submodule changes, any module or submodule
   that includes it by revision needs to be updated to reference the new
   revision.





Bjorklund                    Standards Track                   [Page 33]

RFC 7950                        YANG 1.1                     August 2016


   For example, module "b" imports module "a".

     module a {
       yang-version 1.1;
       namespace "urn:example:a";
       prefix "a";

       revision 2008-01-01 { ... }
       grouping a {
         leaf eh { .... }
       }
     }

     module b {
       yang-version 1.1;
       namespace "urn:example:b";
       prefix "b";

       import a {
         prefix "p";
         revision-date 2008-01-01;
       }

       container bee {
         uses p:a;
       }
     }

   When the author of "a" publishes a new revision, the changes may not
   be acceptable to the author of "b".  If the new revision is
   acceptable, the author of "b" can republish with an updated revision
   in the "import" statement.

   If a module is not imported with a specific revision, it is undefined
   which revision is used.

5.1.2.  Module Hierarchies

   YANG allows modeling of data in multiple hierarchies, where data may
   have more than one top-level node.  Each top-level data node in a
   module defines a separate hierarchy.  Models that have multiple
   top-level nodes are sometimes convenient and are supported by YANG.









Bjorklund                    Standards Track                   [Page 34]

RFC 7950                        YANG 1.1                     August 2016


5.1.2.1.  NETCONF XML Encoding

   NETCONF is capable of carrying any XML content as the payload in the
   <config> and <data> elements.  The top-level nodes of YANG modules
   are encoded as child elements, in any order, within these elements.
   This encapsulation guarantees that the corresponding NETCONF messages
   are always well-formed XML documents.

   For example, an instance of:

     module example-config {
       yang-version 1.1;
       namespace "urn:example:config";
       prefix "co";

       container system { ... }
       container routing { ... }
     }

   could be encoded in NETCONF as:

     <rpc message-id="101"
          xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
          xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
       <edit-config>
         <target>
           <running/>
         </target>
         <config>
           <system xmlns="urn:example:config">
             <!-- system data here -->
           </system>
           <routing xmlns="urn:example:config">
             <!-- routing data here -->
           </routing>
         </config>
       </edit-config>
     </rpc>













Bjorklund                    Standards Track                   [Page 35]

RFC 7950                        YANG 1.1                     August 2016


5.2.  File Layout

   YANG modules and submodules are typically stored in files, one
   "module" or "submodule" statement per file.  The name of the file
   SHOULD be of the form:

     module-or-submodule-name ['@' revision-date] ( '.yang' / '.yin' )

   "module-or-submodule-name" is the name of the module or submodule,
   and the optional "revision-date" is the latest revision of the module
   or submodule, as defined by the "revision" statement (Section 7.1.9).

   The file extension ".yang" denotes that the contents of the file are
   written with YANG syntax (Section 6), and ".yin" denotes that the
   contents of the file are written with YIN syntax (Section 13).

   YANG parsers can find imported modules and included submodules via
   this convention.

5.3.  XML Namespaces

   All YANG definitions are specified within a module.  Each module is
   bound to a distinct XML namespace [XML-NAMES], which is a globally
   unique URI [RFC3986].  A NETCONF client or server uses the namespace
   during XML encoding of data.

   XML namespaces for modules published in RFC streams [RFC4844] MUST be
   assigned by IANA; see Section 14 in [RFC6020].

   XML namespaces for private modules are assigned by the organization
   own
